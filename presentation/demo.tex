\documentclass[aspectratio=169]{beamer}
\hypersetup{pdfpagemode=FullScreen}
\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage{listings}
\bibliographystyle{plainnat}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}
\usepackage[scale=1]{ccicons}
\usepackage{subfig}
% \usepackage{enumitem} % not compatible with enumerate in beamer class
\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\graphicspath{ {./img/} }

\title{HB+Trie}
% \subtitle{Subtítulo}
% \date{\today}
\date{June 02, 2022}
\author{Thushjandan \& François-Xavier}
\institute{Data Management Data Structures}

\begin{document}

\maketitle

\begin{frame}{Agenda}
    \setbeamertemplate{section in toc}[sections numbered]
    \tableofcontents
\end{frame}
\section{Motivations}
\begin{frame}[t]
    \frametitle{Motivations}
       Variable-length sized keys
    
    Disadvantages of B+ trees or LSM-trees:
    \begin{itemize}
    	\item Fanout degree decreases if key length increases
    	\item Tree height grows for the same capacity to maintain
    	\item Benefit of prefix B+ tree becomes limited for randomly distributed keys
    	\item B+ tree nodes are randomly scattered on disk when it ages 
    \end{itemize}
\end{frame}
\section{Overview}
\begin{frame}[t]
    \frametitle{Overview}
    HB+ trie stands for \textit{Hierarchical B+ tree based trie}
    
    Characteristics:
    \begin{itemize}
    	\item Key space is divided into buckets. Every bucket has its own HB+ trie
    	\item High disk throughput due to append-only disk layout
    	 \begin{itemize}
    		\item Regular compaction needed
    	\end{itemize}
    	\item Disk updates are delayed with a \textbf{Write buffer index}
    \end{itemize}
\end{frame}
\begin{frame}[t]
	\frametitle{Overview}
	\begin{figure}[h!]
		\includegraphics[scale=0.5]{architecture}
		\caption{Architecture}
	\end{figure}
	\centering
\end{frame}
\begin{frame}[t]
	\frametitle{Overview}
	HB+ trie stands for \textit{Hierarchical B+ tree based trie}
	
	Characteristics:
	\begin{itemize}
		\item Key space is divided into buckets. Every bucket has its own HB+ trie
		\item High disk throughput due to append-only disk layout
		\item Disk updates are delayed with a \textbf{Write buffer index}
		\item Fixed size chunking of the key
		\item Every unique chunk has a dedicated B+ tree
	\end{itemize}	
\end{frame}
\begin{frame}[t]
	\frametitle{Overview - Chunking}
	\begin{figure}[h!]
		\includegraphics[scale=0.7]{logical_layout}
	\end{figure}
	\centering	
\end{frame}
\begin{frame}[t]
	\frametitle{Overview - Disk layout}
	\begin{figure}[h!]
		\includegraphics[scale=0.5]{disk_layout}
	\end{figure}
	\centering	
\end{frame}
\begin{frame}[t]
	\frametitle{Overview - Write Buffer Index}
	Entries are added to the disk file directly
	
	Write buffer index consists of a hashtable, where keys are hashed
	
	Returns the offset in the file
	\begin{figure}[h!]
		\includegraphics[scale=0.7]{writebufferindex}
	\end{figure}
	\centering	
\end{frame}
\section{Implementation}
\begin{frame}[t]
    \frametitle{Implementation}
    \begin{itemize}
    	\item Using 16 byte chunks for keys
    	\item Each page frame holds a complete B+ subtree.
    	\item Storing pageId in the leaf to reference a B+ subtree
    \end{itemize}
\end{frame}
\begin{frame}[t]
	\frametitle{Implementation - Chunking}
	\begin{figure}[h!]
		\includegraphics[scale=0.19]{code_chunking}
	\end{figure}
	\centering
\end{frame}
\begin{frame}[t]
	\frametitle{Implementation - Insert}
	\begin{figure}[h!]
		\includegraphics[scale=0.19]{code_insert}
	\end{figure}
	\centering
\end{frame}
\begin{frame}[t]
	\frametitle{Implementation - Search}
	\begin{figure}[h!]
		\includegraphics[scale=0.18]{code_search}
	\end{figure}
	\centering
\end{frame}
\begin{frame}[t]
	\frametitle{Implementation - Page frame}
	\begin{figure}[h!]
		\includegraphics[scale=0.16]{code_page}
	\end{figure}
	\centering
\end{frame}
\section{Performance}
\begin{frame}[t]
	\frametitle{Performance}
	\begin{itemize}
		\item \textbf{worst} - avg. 198 bytes key length
		\begin{itemize}
			\item 20 levels of nested prefixes with each 2 branches
		\end{itemize}
		\item \textbf{small} - avg. 65 bytes key length
		\begin{itemize}
			\item 100 randomly generated prefixes
			\item 10000 keys share a common prefix
		\end{itemize}
		\item \textbf{2-level} - avg. 64 bytes key length
		\begin{itemize}
			\item 2 levels of nested prefixes with each 192 branches
		\end{itemize}
	\end{itemize}
\end{frame}
\begin{frame}[t]
    \frametitle{Performance}
    \begin{figure}[h!]
    	\includegraphics[scale=0.5]{comparision_bplus}
    \end{figure}
    \centering
\end{frame}
\begin{frame}[t]
	\frametitle{Performance}
	\begin{figure}[h!]
		\includegraphics[scale=0.35]{performance_rw}
	\end{figure}
	\centering
\end{frame}
\section{Possible improvements}
\begin{frame}[t]
    \frametitle{Possible improvements}
    HB+ trie is not a balanced structure
    \begin{itemize}
    	\item Leads to key skew under specific key pattern
    \end{itemize}

	To address this issue, Leaf B+ tree extension is proposed
	\begin{figure}%
		\centering
		\subfloat[\centering Without extension]{{\includegraphics[scale=0.65]{skew_initialState} }}%
		\qquad
		\subfloat[\centering With extension]{{\includegraphics[scale=0.65]{skew_result} }}%
	\end{figure}
\end{frame}
\begin{frame}[t]
	\frametitle{Possible improvements}
	\begin{itemize}
		\item Performance of Range scans are bad in comparison with B+ tree.
		\item Write Buffer index improves the write throughput and lowers write amplifications
	\end{itemize}
	
\end{frame}
\section{Discussion}
\begin{frame}[t]
	\frametitle{Discussion}
	\begin{itemize}
		\item Leaf Node Extension \& Write buffer index are required
		\item Coachbase Server implements ForestDB storage engine (HB+ trie implementation)
		\item We would use HB+ trie for variable length keys as it combines the best properties of B+ trees and LSM trees
	\end{itemize}
	
\end{frame}
\end{document}
